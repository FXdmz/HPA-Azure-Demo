Good, I can see the structure. You have a `backend` folder (which we created) and a standard Vite project at root with `src/`.

The cleanest solution for Replit is to create a **single Express server** that handles both the API and serves the frontend. Here's exactly what to do:

---

## Step 1: Create the unified server

Create a new file at the root level called **`server.js`**:

```javascript
import express from 'express';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { ClientSecretCredential } from '@azure/identity';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
app.use(express.json());

const PORT = process.env.PORT || 3000;

// Azure credentials from environment
const credential = new ClientSecretCredential(
  process.env.AZURE_TENANT_ID,
  process.env.AZURE_CLIENT_ID,
  process.env.AZURE_CLIENT_SECRET
);

const ENDPOINT = process.env.AI_FOUNDRY_ENDPOINT;
const AGENT_NAME = process.env.AI_AGENT_NAME;
const API_VERSION = "2024-12-01-preview";

// Store threads per session
const sessions = new Map();

// Get access token
async function getAccessToken() {
  const tokenResponse = await credential.getToken("https://cognitiveservices.azure.com/.default");
  return tokenResponse.token;
}

// API Routes
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', agent: AGENT_NAME });
});

app.post('/api/chat', async (req, res) => {
  try {
    const { message, sessionId = 'default' } = req.body;
    
    if (!message) {
      return res.status(400).json({ error: 'Message is required' });
    }

    const token = await getAccessToken();
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    let threadId = sessions.get(sessionId);
    let runData;

    if (!threadId) {
      console.log('Creating new thread and run...');
      const response = await fetch(
        `${ENDPOINT}/threads/runs?api-version=${API_VERSION}`,
        {
          method: 'POST',
          headers,
          body: JSON.stringify({
            assistant_id: AGENT_NAME,
            thread: {
              messages: [{ role: 'user', content: message }]
            }
          })
        }
      );

      if (!response.ok) {
        const error = await response.text();
        console.error('Create thread/run error:', error);
        throw new Error(`Failed to create thread: ${error}`);
      }

      runData = await response.json();
      threadId = runData.thread_id;
      sessions.set(sessionId, threadId);
      console.log('Thread created:', threadId);
    } else {
      console.log('Adding message to thread:', threadId);
      
      const msgResponse = await fetch(
        `${ENDPOINT}/threads/${threadId}/messages?api-version=${API_VERSION}`,
        {
          method: 'POST',
          headers,
          body: JSON.stringify({ role: 'user', content: message })
        }
      );

      if (!msgResponse.ok) {
        const error = await msgResponse.text();
        console.error('Add message error:', error);
        throw new Error(`Failed to add message: ${error}`);
      }

      const runResponse = await fetch(
        `${ENDPOINT}/threads/${threadId}/runs?api-version=${API_VERSION}`,
        {
          method: 'POST',
          headers,
          body: JSON.stringify({ assistant_id: AGENT_NAME })
        }
      );

      if (!runResponse.ok) {
        const error = await runResponse.text();
        console.error('Create run error:', error);
        throw new Error(`Failed to create run: ${error}`);
      }

      runData = await runResponse.json();
    }

    // Poll for completion
    console.log('Polling run:', runData.id);
    let status = runData.status;
    let attempts = 0;
    const maxAttempts = 60;

    while ((status === 'queued' || status === 'in_progress') && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const statusResponse = await fetch(
        `${ENDPOINT}/threads/${threadId}/runs/${runData.id}?api-version=${API_VERSION}`,
        { headers }
      );
      
      const statusData = await statusResponse.json();
      status = statusData.status;
      console.log(`Run status (${attempts + 1}):`, status);
      attempts++;
    }

    if (status !== 'completed') {
      throw new Error(`Run ended with status: ${status}`);
    }

    // Get messages
    const messagesResponse = await fetch(
      `${ENDPOINT}/threads/${threadId}/messages?api-version=${API_VERSION}&order=desc&limit=1`,
      { headers }
    );

    const messagesData = await messagesResponse.json();
    const assistantMessage = messagesData.data?.[0];

    if (!assistantMessage || assistantMessage.role !== 'assistant') {
      throw new Error('No assistant response found');
    }

    let content = '';
    const sources = [];

    for (const item of assistantMessage.content || []) {
      if (item.type === 'text') {
        content = item.text?.value || '';
        
        for (const annotation of item.text?.annotations || []) {
          if (annotation.type === 'file_citation') {
            sources.push('MovieLabs OMC');
          }
        }
      }
    }

    res.json({
      id: assistantMessage.id,
      content,
      sources: [...new Set(sources)],
      threadId
    });

  } catch (error) {
    console.error('Chat error:', error);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/clear', (req, res) => {
  const { sessionId = 'default' } = req.body;
  sessions.delete(sessionId);
  res.json({ status: 'cleared' });
});

// Serve static frontend files
app.use(express.static(join(__dirname, 'dist')));

// SPA fallback - serve index.html for all non-API routes
app.get('*', (req, res) => {
  res.sendFile(join(__dirname, 'dist', 'index.html'));
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Agent: ${AGENT_NAME}`);
  console.log(`Endpoint: ${ENDPOINT}`);
});
```

---

## Step 2: Update your root `package.json`

Make sure your root `package.json` has these scripts and the `"type": "module"` field:

```json
{
  "name": "hpa-greenlight-2026-agent",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "start": "node server.js"
  },
  "dependencies": {
    "@azure/identity": "^4.2.0",
    "express": "^4.18.2",
    ... your other dependencies
  }
}
```

Add `@azure/identity` and `express` to your dependencies if not already there.

---

## Step 3: Update `.replit`

```toml
run = "npm run build && npm start"

[nix]
channel = "stable-24_05"

[deployment]
run = ["sh", "-c", "npm run build && npm start"]
```

---

## Step 4: Update `src/services/agentService.ts`

Replace with this simpler version:

```typescript
interface AgentResponse {
  id: string;
  content: string;
  sources: string[];
  threadId?: string;
}

export class AgentService {
  private sessionId: string;

  constructor() {
    this.sessionId = `session-${Date.now()}`;
  }

  async initialize(): Promise<{ agentId: string; status: string }> {
    try {
      const response = await fetch('/api/health');
      const data = await response.json();
      return { agentId: data.agent, status: 'ready' };
    } catch (error) {
      console.error('Health check failed:', error);
      return { agentId: 'unknown', status: 'error' };
    }
  }

  async sendMessage(content: string): Promise<AgentResponse> {
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: content,
        sessionId: this.sessionId
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to get response');
    }

    return response.json();
  }

  clearHistory(): void {
    fetch('/api/clear', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sessionId: this.sessionId })
    });
    this.sessionId = `session-${Date.now()}`;
  }

  getHistory(): Array<{ role: string; content: string }> {
    return [];
  }
}
```

---

## Step 5: Install dependencies and run

In the Replit Shell:

```bash
npm install @azure/identity express
npm run build
npm start
```

Or just click **Run** after updating `.replit`.

---

This approach builds the frontend first, then serves everything from a single Express server on one port. Let me know when you've made these changes!