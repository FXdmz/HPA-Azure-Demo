## Step-by-Step Replit Instructions

### Step 1: Add Secrets

1. In Replit, click **Tools** in the left sidebar
2. Click **Secrets**
3. Add these 5 secrets one at a time (click **+ New Secret** for each):

| Key | Value |
|-----|-------|
| `AZURE_TENANT_ID` | `e97f9fc7-2bba-4957-bf26-f340d78414b7` |
| `AZURE_CLIENT_ID` | `8bf8bcb9-2228-452f-9a1c-3f764f4c34b6` |
| `AZURE_CLIENT_SECRET` | `yuu8Q~FZA8MPT1EOE.FtQnI6BMBsvwsAdv.1idoT` |
| `AI_FOUNDRY_ENDPOINT` | `https://aescheraicanadaeast-resource.services.ai.azure.com/api/projects/aescheraicanadaeast` |
| `AI_AGENT_NAME` | `aescher2` |

---

### Step 2: Create Backend Files

Create a new folder called `backend` in your project root, then create these files:

**File 1: `backend/package.json`**
```json
{
  "name": "truth-engine-backend",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "@azure/identity": "^4.2.0",
    "@azure/ai-projects": "^1.0.0",
    "cors": "^2.8.5",
    "express": "^4.18.2"
  }
}
```

**File 2: `backend/server.js`**
```javascript
import express from 'express';
import cors from 'cors';
import { ClientSecretCredential } from '@azure/identity';

const app = express();
app.use(cors());
app.use(express.json());

const PORT = 3001;

// Azure credentials from environment
const credential = new ClientSecretCredential(
  process.env.AZURE_TENANT_ID,
  process.env.AZURE_CLIENT_ID,
  process.env.AZURE_CLIENT_SECRET
);

const ENDPOINT = process.env.AI_FOUNDRY_ENDPOINT;
const AGENT_NAME = process.env.AI_AGENT_NAME;
const API_VERSION = "2024-12-01-preview";

// Store threads per session (in production, use a database)
const sessions = new Map();

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', agent: AGENT_NAME });
});

// Get access token
async function getAccessToken() {
  const tokenResponse = await credential.getToken("https://cognitiveservices.azure.com/.default");
  return tokenResponse.token;
}

// Chat endpoint
app.post('/api/chat', async (req, res) => {
  try {
    const { message, sessionId = 'default' } = req.body;
    
    if (!message) {
      return res.status(400).json({ error: 'Message is required' });
    }

    const token = await getAccessToken();
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    let threadId = sessions.get(sessionId);
    let runData;

    if (!threadId) {
      // Create thread and run together
      console.log('Creating new thread and run...');
      const response = await fetch(
        `${ENDPOINT}/threads/runs?api-version=${API_VERSION}`,
        {
          method: 'POST',
          headers,
          body: JSON.stringify({
            assistant_id: AGENT_NAME,
            thread: {
              messages: [{ role: 'user', content: message }]
            }
          })
        }
      );

      if (!response.ok) {
        const error = await response.text();
        console.error('Create thread/run error:', error);
        throw new Error(`Failed to create thread: ${error}`);
      }

      runData = await response.json();
      threadId = runData.thread_id;
      sessions.set(sessionId, threadId);
      console.log('Thread created:', threadId);
    } else {
      // Add message to existing thread
      console.log('Adding message to thread:', threadId);
      
      const msgResponse = await fetch(
        `${ENDPOINT}/threads/${threadId}/messages?api-version=${API_VERSION}`,
        {
          method: 'POST',
          headers,
          body: JSON.stringify({ role: 'user', content: message })
        }
      );

      if (!msgResponse.ok) {
        const error = await msgResponse.text();
        console.error('Add message error:', error);
        throw new Error(`Failed to add message: ${error}`);
      }

      // Create run
      const runResponse = await fetch(
        `${ENDPOINT}/threads/${threadId}/runs?api-version=${API_VERSION}`,
        {
          method: 'POST',
          headers,
          body: JSON.stringify({ assistant_id: AGENT_NAME })
        }
      );

      if (!runResponse.ok) {
        const error = await runResponse.text();
        console.error('Create run error:', error);
        throw new Error(`Failed to create run: ${error}`);
      }

      runData = await runResponse.json();
    }

    // Poll for completion
    console.log('Polling run:', runData.id);
    let status = runData.status;
    let attempts = 0;
    const maxAttempts = 60;

    while ((status === 'queued' || status === 'in_progress') && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const statusResponse = await fetch(
        `${ENDPOINT}/threads/${threadId}/runs/${runData.id}?api-version=${API_VERSION}`,
        { headers }
      );
      
      const statusData = await statusResponse.json();
      status = statusData.status;
      console.log(`Run status (${attempts + 1}):`, status);
      attempts++;
    }

    if (status !== 'completed') {
      throw new Error(`Run ended with status: ${status}`);
    }

    // Get messages
    const messagesResponse = await fetch(
      `${ENDPOINT}/threads/${threadId}/messages?api-version=${API_VERSION}&order=desc&limit=1`,
      { headers }
    );

    const messagesData = await messagesResponse.json();
    const assistantMessage = messagesData.data?.[0];

    if (!assistantMessage || assistantMessage.role !== 'assistant') {
      throw new Error('No assistant response found');
    }

    // Extract content
    let content = '';
    const sources = [];

    for (const item of assistantMessage.content || []) {
      if (item.type === 'text') {
        content = item.text?.value || '';
        
        // Check for citations
        for (const annotation of item.text?.annotations || []) {
          if (annotation.type === 'file_citation') {
            sources.push('MovieLabs OMC');
          }
        }
      }
    }

    res.json({
      id: assistantMessage.id,
      content,
      sources: [...new Set(sources)],
      threadId
    });

  } catch (error) {
    console.error('Chat error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Clear session
app.post('/api/clear', (req, res) => {
  const { sessionId = 'default' } = req.body;
  sessions.delete(sessionId);
  res.json({ status: 'cleared' });
});

app.listen(PORT, () => {
  console.log(`Backend server running on port ${PORT}`);
  console.log(`Agent: ${AGENT_NAME}`);
  console.log(`Endpoint: ${ENDPOINT}`);
});
```

---

### Step 3: Update Frontend agentService.ts

Replace `src/services/agentService.ts` with:

```typescript
interface AgentResponse {
  id: string;
  content: string;
  sources: string[];
  threadId?: string;
}

export class AgentService {
  private backendUrl: string;
  private sessionId: string;

  constructor() {
    // In Replit, backend runs on same host
    this.backendUrl = window.location.origin.replace(':5173', ':3001');
    // If running on Replit deployment, use relative path
    if (!this.backendUrl.includes('localhost')) {
      this.backendUrl = '';  // Will be proxied
    }
    this.sessionId = `session-${Date.now()}`;
  }

  async initialize(): Promise<{ agentId: string; status: string }> {
    try {
      const response = await fetch(`${this.backendUrl}/api/health`);
      const data = await response.json();
      return { agentId: data.agent, status: 'ready' };
    } catch (error) {
      console.error('Backend health check failed:', error);
      return { agentId: 'unknown', status: 'error' };
    }
  }

  async sendMessage(content: string): Promise<AgentResponse> {
    const response = await fetch(`${this.backendUrl}/api/chat`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: content,
        sessionId: this.sessionId
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to get response');
    }

    return response.json();
  }

  clearHistory(): void {
    fetch(`${this.backendUrl}/api/clear`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sessionId: this.sessionId })
    });
    this.sessionId = `session-${Date.now()}`;
  }

  getHistory(): Array<{ role: string; content: string }> {
    return [];
  }
}
```

---

### Step 4: Update the Run Configuration

Update your `.replit` file to run both frontend and backend:

```toml
run = "cd backend && npm install && npm start & cd frontend && npm run dev"

[nix]
channel = "stable-24_05"

[deployment]
run = ["sh", "-c", "cd backend && npm start & cd frontend && npm run preview"]
```

**Or**, if your project structure is different (frontend at root), use:

```toml
run = "cd backend && npm install && npm start & npm run dev"
```

---

### Step 5: Install Backend Dependencies

Open the **Shell** tab in Replit and run:

```bash
cd backend
npm install
```

---

### Step 6: Test

1. Click the **Run** button
2. Wait for both servers to start (you should see "Backend server running on port 3001")
3. Open your app in the Webview
4. Try sending a message

---

Let me know when you've completed these steps or if you hit any errors along the way.